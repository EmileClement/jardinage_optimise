<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>genetique API documentation</title>
<meta name="description" content="Created on Fri May
8 11:31:42 2020 …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>genetique</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri May
8 11:31:42 2020</p>
<p>@author: Leopold &amp; Thomas</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri May  8 11:31:42 2020

@author: Leopold &amp; Thomas
&#34;&#34;&#34;
import random as rd
import threading


import herbier
simulateur = herbier.simulateur
N_bit_espece = herbier.N_bit_espece

class Gene():
    &#34;&#34;&#34;Class abstraite pour l&#39;encapsulation des diférents types de gènes&#34;&#34;&#34;
    decodeur_espece = herbier.dict_herbier

    def __init__(self, *args):
        assert 0, &#34;not implemented&#34;

    def jardin(self) -&gt; simulateur.Jardin:
        &#34;&#34;&#34;renvoie le `simulateur.jardin` corespondant au gène&#34;&#34;&#34;
        assert 0, &#34;not implemented&#34;

    def fitness(self) -&gt; float:
        &#34;&#34;&#34;
        met a jour la caractéristique fit du gene

        Returns
        -------
        fit : float
            le rendement du gene.

        &#34;&#34;&#34;
        if self.fit == None:
            fit = self.jardin().rendement(True)
            self.fit = fit
        return self.fit

    def __mul__(self, other):
        &#34;&#34;&#34;enjambement de deux gène&#34;&#34;&#34;
        assert 0, &#34;not implemented&#34;

    def mutation(self):
        &#34;&#34;&#34;fait muter le gène&#34;&#34;&#34;
        assert 0, &#34;not implemented&#34;

class Gene_naif(Gene):
    &#34;&#34;&#34;Implementation de la representation naive, le gène est une chaine de caractère&#34;&#34;&#34;
    taux_mutation_carra = 0.05
    pourcentage_max_mutation = 0.3

    def __init__(self, len_x, len_y, ADN=&#34;&#34;):
        def generateur_aleatoire_mais_pas_trop():
            decodeur_espece = Gene.decodeur_espece
            calendrier = [0]*365
            ADN = [0]*365
            iterateur = 0
            while iterateur &lt; 365:
                identificateur = &#34;&#34;
                for i in range(N_bit_espece):
                    identificateur += str(rd.randint(0,1))
                plante_aléatoire = decodeur_espece[identificateur]
                if identificateur == N_bit_espece*&#34;0&#34;:

                    ADN[iterateur] =  N_bit_espece*&#34;0&#34;
                    iterateur += 1
                else:
                    time_chunk = plante_aléatoire().time_chunk
                    if iterateur + time_chunk &lt; 363:
                        calendrier[iterateur:iterateur + time_chunk] = [plante_aléatoire()]*time_chunk
                        ADN[iterateur:iterateur + time_chunk] = [identificateur]*time_chunk
                        calendrier[iterateur + time_chunk] = simulateur.Jachere()
                        ADN[iterateur + time_chunk] = N_bit_espece*&#34;0&#34;
                        iterateur += time_chunk + 1
                    else:
                        calendrier[iterateur:365] = [plante_aléatoire()]*(364-iterateur +1)
                        ADN[iterateur:365] = [identificateur]*(364-iterateur +1)
                        iterateur = 365
            return &#34;&#34;.join(ADN)
        self.len_x = len_x
        self.len_y = len_y
        if ADN:
            self.ADN = ADN
        else:
            self.ADN = &#34;&#34;
            for x in range(len_x):
                for y in range(len_y):
                    self.ADN += generateur_aleatoire_mais_pas_trop()
                    #print(self.ADN)
        self.fit = None

    @classmethod
    def from_file(cls, adn, fit, len_x, len_y):
        &#34;&#34;&#34;
        reconstruit le gene à partir des informations contenues dans le fichier de sauvegarde

        Parameters
        ----------
        cls : type
            DESCRIPTION.
        adn : str
            chaine binaire du gene
        fit : float or None
            fitness du gene
        len_x : int
            DESCRIPTION.
        len_y : int
            DESCRIPTION.

        Returns
        -------
        gene : Gene
            gene reconstruit

        &#34;&#34;&#34;
        gene = cls(len_x, len_y, adn)
        gene.fit = fit
        return gene

    def __str__(self):
        return &#34;{};{}&#34;.format(self.fit, hex(int(self.ADN, 2)))

    def __repr__(self):
        n = int(self.ADN, 2)
        return &#34;gene : {}&#34;.format(hex(n))

    def jardin(self) -&gt; simulateur.Jardin:
        jar = simulateur.Jardin(self.len_x, self.len_y)
        for x in range(self.len_x):
            for y in range(self.len_y):
                emplacement = jar.emplacement[y][x]
                ebauche = []
                for jour in range(365):
                    allele = self.ADN[(x + (y * self.len_x)) * 365 + N_bit_espece*jour :
                                      (x + (y * self.len_x)) * 365 + N_bit_espece*jour
                                      + N_bit_espece]
                    try:
                        ebauche += [Gene.decodeur_espece[allele]]
                    except KeyError:
                        ebauche += [simulateur.Jachere]
                idx_exploration = 0
                while idx_exploration &lt; 365:
                    type_actuel = ebauche[idx_exploration]
                    if type_actuel == simulateur.Jachere:
                        idx_exploration += 1
                    else:
                        idx_depart = idx_exploration
                        while (idx_exploration &lt; 365) and ebauche[idx_exploration] == type_actuel:
                            idx_exploration += 1
                        idx_fin = idx_exploration
                        plante = type_actuel()
                        try:
                            plante.planter(emplacement, idx_depart, idx_fin, jar) #,x,y,jar)
                        except ValueError:
                            pass
        return jar

    def __mul__(self, other):
        idx_coupe = rd.randint(0, len(self.ADN))
        return Gene_naif(self.len_x, self.len_y, self.ADN[:idx_coupe] + other.ADN[idx_coupe:])

    def mutation(self):
        if rd.random() &lt; Gene_naif.taux_mutation_carra:
            nbr_caractere_a_muter = rd.randint(1, round(Gene_naif.pourcentage_max_mutation*len(self.ADN)))
            place_caractere = rd.randint(0, len(self.ADN)-nbr_caractere_a_muter-1)
            inverse = &#34;&#34;
            for bit in self.ADN[place_caractere:place_caractere+nbr_caractere_a_muter]:
                if bit == &#34;0&#34;:
                    inverse += &#34;1&#34;
                else:
                    inverse += &#34;0&#34;
            if ((len(self.ADN[:place_caractere]
                    + inverse
                    + self.ADN[place_caractere
                               + nbr_caractere_a_muter:])) !=
                                                            len(self.ADN)):
                raise ValueError
            else:
                self.ADN = self.ADN[place_caractere] + inverse + self.ADN[place_caractere + nbr_caractere_a_muter:]

class Composant():
    &#34;&#34;&#34;implementation des composants des genes composes&#34;&#34;&#34;
    next_id = 0

    taux_mutation_date = 0.3
    ecart_type_mutation_date = 10
    taux_mutation_position = 0.00
    taux_mutation_activite = 0.05

    def __init__(self, espece, date_plantaison, date_recolte, position, actif = True, idx = None):
        if idx == None:
            self.id = Composant.next_id
            Composant.next_id += 1
        else:
            self.id = idx

        self.position = position
        self.actif = actif
        self.espece = espece
        self.plantage = date_plantaison
        self.recolte = date_recolte

    def __repr__(self):
        return &#34;{0}:{1}@{2},{3}-&gt;{4},{5}&#34;.format(self.id, self.espece, self.position,
                                        self.plantage, self.recolte, self.actif)
    def copy(self):
        &#34;&#34;&#34;permet de creer une copie du composant avec le meme numero d&#39;innovation&#34;&#34;&#34;
        x, y = self.position
        espece = self.espece
        date_plantaison = self. plantage
        date_recolte = self.recolte
        actif = self.actif
        id = self.id
        return Composant(espece, date_plantaison, date_recolte, (x,y), actif, id)

    @classmethod
    def random(cls, len_x, len_y):
        &#34;&#34;&#34;permet de creer un nouvau composant aleatoire avec un nouveau numero d&#39;innovation&#34;&#34;&#34;
        return cls(rd.choice(herbier.list_espece),
                   rd.randint(0, 364),
                   rd.randint(0, 364),
                   (rd.randint(0,len_x-1), rd.randint(0, len_y-1)))

    def __or__(self, other):
        return rd.choice([self, other])

    def mutation(self):
        if rd.random()&lt;=Composant.taux_mutation_date:
            self.plantage += round(rd.gauss(0, Composant.ecart_type_mutation_date))
            self.plantage %= 365
        if rd.random()&lt;=Composant.taux_mutation_date:
            self.recolte += round(rd.gauss(0, Composant.ecart_type_mutation_date))
            self.recolte %= 365
        if rd.random() &lt;= Composant.taux_mutation_activite:
            self.actif = not self.actif

class Gene_compose(Gene):
    &#34;&#34;&#34;implementation des genes composes&#34;&#34;&#34;
    taux_mutation_new_componant = 0.3

    def __init__(self, len_x, len_y, composants = 10):
        self.len_x = len_x
        self.len_y = len_y
        if isinstance(composants, int):
            self.composants = [Composant.random(len_x, len_y) for _ in range(composants)]
        else:
            self.composants = composants
        self.fit = None

    def __repr__(self):
        chaine = &#34;&#34;
        for elem in self.composants:
            chaine += &#34;{}\n&#34;.format(elem.__repr__())
        return &#34;gene compose ({0},{1}) :\n{2}&#34;.format(self.len_x, self.len_y, chaine)

    def mutation(self):
        for elem in self.composants:
            elem.mutation()

        if rd.random() &lt;= Gene_compose.taux_mutation_new_componant:
            self.composants.append(Composant.random(self.len_x, self.len_y))

    def __mul__(self, other):
        parent_A = [None for _ in range(Composant.next_id)]
        parent_B = [None for _ in range(Composant.next_id)]
        for composant in self.composants:
            parent_A[composant.id] = composant
        for composant in other.composants:
            parent_B[composant.id] = composant
        fils = [None for _ in range(Composant.next_id)]
        for i in range(Composant.next_id):
            comp_a = parent_A[i]
            comp_b = parent_B[i]
            if (comp_a == None) and (comp_b == None):
                pass
            elif isinstance(comp_a, Composant) and isinstance(comp_b, Composant):
                fils[i] = (comp_a | comp_b).copy()
            elif isinstance(comp_a, Composant) and (comp_b == None):
                fils[i] = comp_a.copy()
            elif isinstance(comp_b, Composant) and (comp_a == None):
                fils[i] = comp_b.copy()
            else:
                raise ValueError
        gene = Gene_compose(self.len_x, self.len_y, [elem for elem in fils if elem != None])
        return gene

    def jardin(self):
        jar = simulateur.Jardin(self.len_x, self.len_y)
        for comp in self.composants:
            if comp.actif:
                try:
                    empl = jar.emplacement[comp.position[1]][comp.position[0]]
                    plante = comp.espece()
                    plante.planter(empl, comp.plantage, comp.recolte,jar)

                except ValueError:
                    pass
        return jar
    
    def recette(self):
        &#34;&#34;&#34;permet de convertir le gene en un texte comprehensible pour l&#39;utilisateur representant la plannification des cultures du jardin&#34;&#34;&#34;
        jar = simulateur.Jardin(self.len_x, self.len_y)
        liste_commande = []
        for comp in self.composants:
            if comp.actif:
                try:
                    empl = jar.emplacement[comp.position[1]][comp.position[0]]
                    plante = comp.espece()
                    plante.planter(empl, comp.plantage, comp.recolte, jar)
                    liste_commande.append(&#34;le jour {:0&gt;3}, en ({},{}), planter des {}&#34;.format(comp.plantage, comp.position[1], comp.position[0], plante))
                    liste_commande.append(&#34;le jour {:0&gt;3}, en ({},{}), recolter des {}&#34;.format(comp.recolte, comp.position[1], comp.position[0], plante))
                except ValueError:
                    pass
        liste_commande.sort()
        return &#34;\n&#34;.join(liste_commande)


class Generation():
    &#34;&#34;&#34;objet permettant de representer une generation dans l&#39;algorithme&#34;&#34;&#34;
    multithreading_actif = False
    
    @classmethod
    def from_file(cls, path):
        &#34;&#34;&#34;
        reconstruit la generation a partir d&#39;un fichier

        Parameters
        ----------
        cls : type
            DESCRIPTION.
        path : str
            chemin du fichier contenant la sauvegarde

        Raises
        ------
        IOError
            DESCRIPTION.
        Exception
            DESCRIPTION.

        Returns
        -------
        generation : Generation
            generation corespondant au fichier

        &#34;&#34;&#34;
        try:
            file = open(path+&#34;.txt&#34;, &#34;r&#34;)
            lines = file.readlines()
            file.close()
        except Exception:
            raise IOError(&#34;&#34;&#34;le fichier &#34;{}&#34; ne s&#39;ouvre pas&#34;&#34;&#34;.format(path+&#34;.txt&#34;))
        try:
            en_tete = lines.pop(0)
            en_tete = en_tete.split(&#34;;&#34;)
            len_x = int(en_tete[0])
            len_y = int(en_tete[1])
            evaluee = bool(int(en_tete[2]))
        except Exception:
            raise Exception(&#34;&#34;&#34;Entete invalide&#34;&#34;&#34;)
        try:
            genes = []
            for n, ligne in enumerate(lines):
                ligne = ligne.split(&#39;;&#39;)
                fit = ligne[0]
                adn = ligne[1][:-1]
                adn = bin(int(adn, 16))[2:]
                if evaluee:
                    fit = float(fit)
                else:
                    fit = None
                genes.append(Gene_naif.from_file(adn, fit, len_x, len_y))
        except Exception:
            Exception(&#34;&#34;&#34;Contenu invalide ligne {}&#34;&#34;&#34;.format(n))

        generation = cls(genes)
        generation.evaluee = evaluee
        return generation

    def __init__(self, genes):
        self.genes = []
        for elem in genes:
            if not isinstance(elem, Gene):
                raise TypeError(&#34;Ce n&#39;est pas un gene&#34;)
            self.genes.append(elem)
        self.evaluee = False

    def generation_suivante(self):
        &#34;&#34;&#34;
        calcule la génération suivante

        Returns
        -------
        Generation
            La generation suivante

        &#34;&#34;&#34;
        N = len(self.genes)
        self.evaluation()
        gene = self._selection()

        new_gene = []
        while len(new_gene) &lt;= N:
            g1 = rd.choice(gene)
            g2 = rd.choice(gene)
            g = (g1 * g2)
            g.mutation()
            new_gene.append(g)
        gen_suivante = Generation(new_gene)
        return gen_suivante

    def evaluation(self):
        &#34;&#34;&#34;
        Permet de trier la liste des genes dans l&#39;odre décroissant de qualité

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if Generation.multithreading_actif :
            liste_evaluateur = []
            for gene in self.genes:
                liste_evaluateur.append(Evaluateur(gene))
            
            for evaluateur in liste_evaluateur:
                evaluateur.start()
            
            for evaluateur in liste_evaluateur:
                evaluateur.join()
            
        self.genes.sort(key=Gene.fitness, reverse=True)
        self.evaluee = True

    def _selection(self) -&gt; list:
        &#34;&#34;&#34;
        Permet de selectionner les 10% meilleurs élements de la liste de genes, Cette dernière doit être triée du meilleur [0] au moins bon [-1].

        Returns
        -------
        None.

        &#34;&#34;&#34;

        if self.evaluee == False:
            self.evaluation()
        selection = []
        selection += self.genes[:(len(self.genes)//10)]
        weight = [gene.fitness() for gene in self.genes[(len(self.genes)//10):]]
        selection += rd.choices(self.genes[(len(self.genes)//10):], weight, k = len(selection))
        return selection

    def __str__(self):
        chaine = &#34;{1};{2};{0}\n&#34;.format(int(self.evaluee), self.genes[0].len_x,  self.genes[0].len_y)
        for gene in self.genes:
            chaine += str(gene)+&#34;\n&#34;
        return chaine

    def save(self, nom, emplacement = &#34;save&#34;):
        &#34;&#34;&#34;
        enregistre la géneration dans un fichier

        Parameters
        ----------
        nom : str
            nom de la sauvegarde
        emplacement : str, optional
            emplacement de la sauvegarde. The default is &#34;save&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        file = open(emplacement + &#34;/&#34; + nom + &#39;.txt&#39;, &#39;w&#39;)
        file.write(str(self))
        file.close()

    def get_fitness(self):
        &#34;&#34;&#34;
        renvoit la liste des fitness de la generation

        Returns
        -------
        fitness : list[int]
            liste des fitness de la generation

        &#34;&#34;&#34;
        if not self.evaluee:
            self.evaluation()
        fitness = []
        for gene in self.genes:
            fitness.append(gene.fit)
        return fitness


class Essai():
    &#34;&#34;&#34;objet representant un simulation en entier&#34;&#34;&#34;
    def __init__(self, generation_initial):

        self.generations = []
        self.generations.append(generation_initial)

    @classmethod
    def naif_non_random(cls, len_x, len_y, taille):
        &#34;&#34;&#34;permet d&#39;initialiser une nouvelle simulation avec des `genetique.Gene_naif`, les genes ne sont pas entierement aleatoires&#34;&#34;&#34;
        genes = [Gene_naif(len_x, len_y) for _ in range(taille)]
        generation = Generation(genes)
        return cls(generation)

    @classmethod
    def composee_vide(cls, len_x, len_y, taille):
        &#34;&#34;&#34;permet d&#39;initialiser une nouvelle simulation avec des `genetique.Gene_compose`, les genes ne sont pas entierement aleatoires&#34;&#34;&#34;
        genes = [Gene_compose(len_x, len_y, 0) for _ in range(taille)]
        generation = Generation(genes)
        return cls(generation)

    def generation_suivante(self):
        &#34;&#34;&#34;
        Rajoute la géneration suivante dans la liste des génerations

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.generations.append(self.generations[-1].generation_suivante())

    def save(self, nom, emplacement = &#34;save&#34;):
        &#34;&#34;&#34;
        sauvegarde l&#39;essai dans l&#39;emplacement voulu, avec le nom voulu. ne fonctionne que pour les gene_naif

        Parameters
        ----------
        nom : str
            nom de la save, &#34;foo&#34; pour obtenir &#34;foo_0.txt&#34;...&#34;foo_n.txt&#34;
        emplacement : str, optional
            emplacement des sauvegardes. The default is &#34;save&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for n, generation in enumerate(self.generations):
            generation.save(&#34;{0}_{1}&#34;.format(nom, n), emplacement)

    @classmethod
    def load_save(cls, nom, emplacement = &#34;save&#34;):
        &#34;&#34;&#34;charge une sauvegarde d&#39;essai, ne fonctionne que pour les genes naifs.&#34;&#34;&#34;
        essai = cls(0, 0, 0, True)
        idx = 0
        essai.generations.append(Generation.from_file(
            &#34;{}/{}_0&#34;.format(emplacement, nom)))
        while True:
            idx +=1
            try:
                essai.generations.append(Generation.from_file(
                    &#34;{}/{}_{}&#34;.format(emplacement, nom, idx)))
            except Exception:
                break
        return essai

    def evolution_statistique(self, plt, n_mesure=10):
        &#34;&#34;&#34;permet de tracer une evolution de la repartition de la fitness au cours du temps, utile pour voir l&#39;evolution des genes.&#34;&#34;&#34;
        import numpy as np
        liste_indice = np.linspace(0, len(self.generations)-1, n_mesure, dtype=int)
        distribution = []
        for n, generation in enumerate(self.generations):
            if n in liste_indice:
                distribution.append(generation.get_fitness())
        plt.violinplot(distribution, liste_indice,
                       widths = len(self.generations)/(2*n_mesure),
                       showmeans = True)
        plt.title(&#34;Evolution de la repartition statistique du\nrendement en fonction des generations&#34;)
        plt.xlabel(&#34;generation&#34;)
        plt.ylabel(&#34;rendement $kg/m^2$&#34;)
        return plt

class Evaluateur(threading.Thread):
    &#34;&#34;&#34;classe permetant le calcul en parallele du rendement des genes, permet un gain de temps notable &#34;&#34;&#34;
    def __init__(self, gene):
        threading.Thread.__init__(self)
        self.gene = gene
    
    def run(self):
        self.gene.fitness()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="genetique.Composant"><code class="flex name class">
<span>class <span class="ident">Composant</span></span>
<span>(</span><span>espece, date_plantaison, date_recolte, position, actif=True, idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>implementation des composants des genes composes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Composant():
    &#34;&#34;&#34;implementation des composants des genes composes&#34;&#34;&#34;
    next_id = 0

    taux_mutation_date = 0.3
    ecart_type_mutation_date = 10
    taux_mutation_position = 0.00
    taux_mutation_activite = 0.05

    def __init__(self, espece, date_plantaison, date_recolte, position, actif = True, idx = None):
        if idx == None:
            self.id = Composant.next_id
            Composant.next_id += 1
        else:
            self.id = idx

        self.position = position
        self.actif = actif
        self.espece = espece
        self.plantage = date_plantaison
        self.recolte = date_recolte

    def __repr__(self):
        return &#34;{0}:{1}@{2},{3}-&gt;{4},{5}&#34;.format(self.id, self.espece, self.position,
                                        self.plantage, self.recolte, self.actif)
    def copy(self):
        &#34;&#34;&#34;permet de creer une copie du composant avec le meme numero d&#39;innovation&#34;&#34;&#34;
        x, y = self.position
        espece = self.espece
        date_plantaison = self. plantage
        date_recolte = self.recolte
        actif = self.actif
        id = self.id
        return Composant(espece, date_plantaison, date_recolte, (x,y), actif, id)

    @classmethod
    def random(cls, len_x, len_y):
        &#34;&#34;&#34;permet de creer un nouvau composant aleatoire avec un nouveau numero d&#39;innovation&#34;&#34;&#34;
        return cls(rd.choice(herbier.list_espece),
                   rd.randint(0, 364),
                   rd.randint(0, 364),
                   (rd.randint(0,len_x-1), rd.randint(0, len_y-1)))

    def __or__(self, other):
        return rd.choice([self, other])

    def mutation(self):
        if rd.random()&lt;=Composant.taux_mutation_date:
            self.plantage += round(rd.gauss(0, Composant.ecart_type_mutation_date))
            self.plantage %= 365
        if rd.random()&lt;=Composant.taux_mutation_date:
            self.recolte += round(rd.gauss(0, Composant.ecart_type_mutation_date))
            self.recolte %= 365
        if rd.random() &lt;= Composant.taux_mutation_activite:
            self.actif = not self.actif</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="genetique.Composant.ecart_type_mutation_date"><code class="name">var <span class="ident">ecart_type_mutation_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genetique.Composant.next_id"><code class="name">var <span class="ident">next_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genetique.Composant.taux_mutation_activite"><code class="name">var <span class="ident">taux_mutation_activite</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genetique.Composant.taux_mutation_date"><code class="name">var <span class="ident">taux_mutation_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genetique.Composant.taux_mutation_position"><code class="name">var <span class="ident">taux_mutation_position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="genetique.Composant.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>len_x, len_y)</span>
</code></dt>
<dd>
<div class="desc"><p>permet de creer un nouvau composant aleatoire avec un nouveau numero d'innovation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def random(cls, len_x, len_y):
    &#34;&#34;&#34;permet de creer un nouvau composant aleatoire avec un nouveau numero d&#39;innovation&#34;&#34;&#34;
    return cls(rd.choice(herbier.list_espece),
               rd.randint(0, 364),
               rd.randint(0, 364),
               (rd.randint(0,len_x-1), rd.randint(0, len_y-1)))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genetique.Composant.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>permet de creer une copie du composant avec le meme numero d'innovation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;permet de creer une copie du composant avec le meme numero d&#39;innovation&#34;&#34;&#34;
    x, y = self.position
    espece = self.espece
    date_plantaison = self. plantage
    date_recolte = self.recolte
    actif = self.actif
    id = self.id
    return Composant(espece, date_plantaison, date_recolte, (x,y), actif, id)</code></pre>
</details>
</dd>
<dt id="genetique.Composant.mutation"><code class="name flex">
<span>def <span class="ident">mutation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutation(self):
    if rd.random()&lt;=Composant.taux_mutation_date:
        self.plantage += round(rd.gauss(0, Composant.ecart_type_mutation_date))
        self.plantage %= 365
    if rd.random()&lt;=Composant.taux_mutation_date:
        self.recolte += round(rd.gauss(0, Composant.ecart_type_mutation_date))
        self.recolte %= 365
    if rd.random() &lt;= Composant.taux_mutation_activite:
        self.actif = not self.actif</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="genetique.Essai"><code class="flex name class">
<span>class <span class="ident">Essai</span></span>
<span>(</span><span>generation_initial)</span>
</code></dt>
<dd>
<div class="desc"><p>objet representant un simulation en entier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Essai():
    &#34;&#34;&#34;objet representant un simulation en entier&#34;&#34;&#34;
    def __init__(self, generation_initial):

        self.generations = []
        self.generations.append(generation_initial)

    @classmethod
    def naif_non_random(cls, len_x, len_y, taille):
        &#34;&#34;&#34;permet d&#39;initialiser une nouvelle simulation avec des `genetique.Gene_naif`, les genes ne sont pas entierement aleatoires&#34;&#34;&#34;
        genes = [Gene_naif(len_x, len_y) for _ in range(taille)]
        generation = Generation(genes)
        return cls(generation)

    @classmethod
    def composee_vide(cls, len_x, len_y, taille):
        &#34;&#34;&#34;permet d&#39;initialiser une nouvelle simulation avec des `genetique.Gene_compose`, les genes ne sont pas entierement aleatoires&#34;&#34;&#34;
        genes = [Gene_compose(len_x, len_y, 0) for _ in range(taille)]
        generation = Generation(genes)
        return cls(generation)

    def generation_suivante(self):
        &#34;&#34;&#34;
        Rajoute la géneration suivante dans la liste des génerations

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.generations.append(self.generations[-1].generation_suivante())

    def save(self, nom, emplacement = &#34;save&#34;):
        &#34;&#34;&#34;
        sauvegarde l&#39;essai dans l&#39;emplacement voulu, avec le nom voulu. ne fonctionne que pour les gene_naif

        Parameters
        ----------
        nom : str
            nom de la save, &#34;foo&#34; pour obtenir &#34;foo_0.txt&#34;...&#34;foo_n.txt&#34;
        emplacement : str, optional
            emplacement des sauvegardes. The default is &#34;save&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for n, generation in enumerate(self.generations):
            generation.save(&#34;{0}_{1}&#34;.format(nom, n), emplacement)

    @classmethod
    def load_save(cls, nom, emplacement = &#34;save&#34;):
        &#34;&#34;&#34;charge une sauvegarde d&#39;essai, ne fonctionne que pour les genes naifs.&#34;&#34;&#34;
        essai = cls(0, 0, 0, True)
        idx = 0
        essai.generations.append(Generation.from_file(
            &#34;{}/{}_0&#34;.format(emplacement, nom)))
        while True:
            idx +=1
            try:
                essai.generations.append(Generation.from_file(
                    &#34;{}/{}_{}&#34;.format(emplacement, nom, idx)))
            except Exception:
                break
        return essai

    def evolution_statistique(self, plt, n_mesure=10):
        &#34;&#34;&#34;permet de tracer une evolution de la repartition de la fitness au cours du temps, utile pour voir l&#39;evolution des genes.&#34;&#34;&#34;
        import numpy as np
        liste_indice = np.linspace(0, len(self.generations)-1, n_mesure, dtype=int)
        distribution = []
        for n, generation in enumerate(self.generations):
            if n in liste_indice:
                distribution.append(generation.get_fitness())
        plt.violinplot(distribution, liste_indice,
                       widths = len(self.generations)/(2*n_mesure),
                       showmeans = True)
        plt.title(&#34;Evolution de la repartition statistique du\nrendement en fonction des generations&#34;)
        plt.xlabel(&#34;generation&#34;)
        plt.ylabel(&#34;rendement $kg/m^2$&#34;)
        return plt</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="genetique.Essai.composee_vide"><code class="name flex">
<span>def <span class="ident">composee_vide</span></span>(<span>len_x, len_y, taille)</span>
</code></dt>
<dd>
<div class="desc"><p>permet d'initialiser une nouvelle simulation avec des <code><a title="genetique.Gene_compose" href="#genetique.Gene_compose">Gene_compose</a></code>, les genes ne sont pas entierement aleatoires</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def composee_vide(cls, len_x, len_y, taille):
    &#34;&#34;&#34;permet d&#39;initialiser une nouvelle simulation avec des `genetique.Gene_compose`, les genes ne sont pas entierement aleatoires&#34;&#34;&#34;
    genes = [Gene_compose(len_x, len_y, 0) for _ in range(taille)]
    generation = Generation(genes)
    return cls(generation)</code></pre>
</details>
</dd>
<dt id="genetique.Essai.load_save"><code class="name flex">
<span>def <span class="ident">load_save</span></span>(<span>nom, emplacement='save')</span>
</code></dt>
<dd>
<div class="desc"><p>charge une sauvegarde d'essai, ne fonctionne que pour les genes naifs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_save(cls, nom, emplacement = &#34;save&#34;):
    &#34;&#34;&#34;charge une sauvegarde d&#39;essai, ne fonctionne que pour les genes naifs.&#34;&#34;&#34;
    essai = cls(0, 0, 0, True)
    idx = 0
    essai.generations.append(Generation.from_file(
        &#34;{}/{}_0&#34;.format(emplacement, nom)))
    while True:
        idx +=1
        try:
            essai.generations.append(Generation.from_file(
                &#34;{}/{}_{}&#34;.format(emplacement, nom, idx)))
        except Exception:
            break
    return essai</code></pre>
</details>
</dd>
<dt id="genetique.Essai.naif_non_random"><code class="name flex">
<span>def <span class="ident">naif_non_random</span></span>(<span>len_x, len_y, taille)</span>
</code></dt>
<dd>
<div class="desc"><p>permet d'initialiser une nouvelle simulation avec des <code><a title="genetique.Gene_naif" href="#genetique.Gene_naif">Gene_naif</a></code>, les genes ne sont pas entierement aleatoires</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def naif_non_random(cls, len_x, len_y, taille):
    &#34;&#34;&#34;permet d&#39;initialiser une nouvelle simulation avec des `genetique.Gene_naif`, les genes ne sont pas entierement aleatoires&#34;&#34;&#34;
    genes = [Gene_naif(len_x, len_y) for _ in range(taille)]
    generation = Generation(genes)
    return cls(generation)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genetique.Essai.evolution_statistique"><code class="name flex">
<span>def <span class="ident">evolution_statistique</span></span>(<span>self, plt, n_mesure=10)</span>
</code></dt>
<dd>
<div class="desc"><p>permet de tracer une evolution de la repartition de la fitness au cours du temps, utile pour voir l'evolution des genes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evolution_statistique(self, plt, n_mesure=10):
    &#34;&#34;&#34;permet de tracer une evolution de la repartition de la fitness au cours du temps, utile pour voir l&#39;evolution des genes.&#34;&#34;&#34;
    import numpy as np
    liste_indice = np.linspace(0, len(self.generations)-1, n_mesure, dtype=int)
    distribution = []
    for n, generation in enumerate(self.generations):
        if n in liste_indice:
            distribution.append(generation.get_fitness())
    plt.violinplot(distribution, liste_indice,
                   widths = len(self.generations)/(2*n_mesure),
                   showmeans = True)
    plt.title(&#34;Evolution de la repartition statistique du\nrendement en fonction des generations&#34;)
    plt.xlabel(&#34;generation&#34;)
    plt.ylabel(&#34;rendement $kg/m^2$&#34;)
    return plt</code></pre>
</details>
</dd>
<dt id="genetique.Essai.generation_suivante"><code class="name flex">
<span>def <span class="ident">generation_suivante</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rajoute la géneration suivante dans la liste des génerations</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generation_suivante(self):
    &#34;&#34;&#34;
    Rajoute la géneration suivante dans la liste des génerations

    Returns
    -------
    None.

    &#34;&#34;&#34;
    self.generations.append(self.generations[-1].generation_suivante())</code></pre>
</details>
</dd>
<dt id="genetique.Essai.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, nom, emplacement='save')</span>
</code></dt>
<dd>
<div class="desc"><p>sauvegarde l'essai dans l'emplacement voulu, avec le nom voulu. ne fonctionne que pour les gene_naif</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nom</code></strong> :&ensp;<code>str</code></dt>
<dd>nom de la save, "foo" pour obtenir "foo_0.txt"&hellip;"foo_n.txt"</dd>
<dt><strong><code>emplacement</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>emplacement des sauvegardes. The default is "save".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, nom, emplacement = &#34;save&#34;):
    &#34;&#34;&#34;
    sauvegarde l&#39;essai dans l&#39;emplacement voulu, avec le nom voulu. ne fonctionne que pour les gene_naif

    Parameters
    ----------
    nom : str
        nom de la save, &#34;foo&#34; pour obtenir &#34;foo_0.txt&#34;...&#34;foo_n.txt&#34;
    emplacement : str, optional
        emplacement des sauvegardes. The default is &#34;save&#34;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    for n, generation in enumerate(self.generations):
        generation.save(&#34;{0}_{1}&#34;.format(nom, n), emplacement)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="genetique.Evaluateur"><code class="flex name class">
<span>class <span class="ident">Evaluateur</span></span>
<span>(</span><span>gene)</span>
</code></dt>
<dd>
<div class="desc"><p>classe permetant le calcul en parallele du rendement des genes, permet un gain de temps notable </p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Evaluateur(threading.Thread):
    &#34;&#34;&#34;classe permetant le calcul en parallele du rendement des genes, permet un gain de temps notable &#34;&#34;&#34;
    def __init__(self, gene):
        threading.Thread.__init__(self)
        self.gene = gene
    
    def run(self):
        self.gene.fitness()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="genetique.Evaluateur.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.gene.fitness()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="genetique.Gene"><code class="flex name class">
<span>class <span class="ident">Gene</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Class abstraite pour l'encapsulation des diférents types de gènes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gene():
    &#34;&#34;&#34;Class abstraite pour l&#39;encapsulation des diférents types de gènes&#34;&#34;&#34;
    decodeur_espece = herbier.dict_herbier

    def __init__(self, *args):
        assert 0, &#34;not implemented&#34;

    def jardin(self) -&gt; simulateur.Jardin:
        &#34;&#34;&#34;renvoie le `simulateur.jardin` corespondant au gène&#34;&#34;&#34;
        assert 0, &#34;not implemented&#34;

    def fitness(self) -&gt; float:
        &#34;&#34;&#34;
        met a jour la caractéristique fit du gene

        Returns
        -------
        fit : float
            le rendement du gene.

        &#34;&#34;&#34;
        if self.fit == None:
            fit = self.jardin().rendement(True)
            self.fit = fit
        return self.fit

    def __mul__(self, other):
        &#34;&#34;&#34;enjambement de deux gène&#34;&#34;&#34;
        assert 0, &#34;not implemented&#34;

    def mutation(self):
        &#34;&#34;&#34;fait muter le gène&#34;&#34;&#34;
        assert 0, &#34;not implemented&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="genetique.Gene_compose" href="#genetique.Gene_compose">Gene_compose</a></li>
<li><a title="genetique.Gene_naif" href="#genetique.Gene_naif">Gene_naif</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="genetique.Gene.decodeur_espece"><code class="name">var <span class="ident">decodeur_espece</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genetique.Gene.fitness"><code class="name flex">
<span>def <span class="ident">fitness</span></span>(<span>self) -> float</span>
</code></dt>
<dd>
<div class="desc"><p>met a jour la caractéristique fit du gene</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fit</code></strong> :&ensp;<code>float</code></dt>
<dd>le rendement du gene.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitness(self) -&gt; float:
    &#34;&#34;&#34;
    met a jour la caractéristique fit du gene

    Returns
    -------
    fit : float
        le rendement du gene.

    &#34;&#34;&#34;
    if self.fit == None:
        fit = self.jardin().rendement(True)
        self.fit = fit
    return self.fit</code></pre>
</details>
</dd>
<dt id="genetique.Gene.jardin"><code class="name flex">
<span>def <span class="ident">jardin</span></span>(<span>self) -> <a title="simulateur.Jardin" href="simulateur.html#simulateur.Jardin">Jardin</a></span>
</code></dt>
<dd>
<div class="desc"><p>renvoie le <code>simulateur.jardin</code> corespondant au gène</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jardin(self) -&gt; simulateur.Jardin:
    &#34;&#34;&#34;renvoie le `simulateur.jardin` corespondant au gène&#34;&#34;&#34;
    assert 0, &#34;not implemented&#34;</code></pre>
</details>
</dd>
<dt id="genetique.Gene.mutation"><code class="name flex">
<span>def <span class="ident">mutation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>fait muter le gène</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutation(self):
    &#34;&#34;&#34;fait muter le gène&#34;&#34;&#34;
    assert 0, &#34;not implemented&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="genetique.Gene_compose"><code class="flex name class">
<span>class <span class="ident">Gene_compose</span></span>
<span>(</span><span>len_x, len_y, composants=10)</span>
</code></dt>
<dd>
<div class="desc"><p>implementation des genes composes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gene_compose(Gene):
    &#34;&#34;&#34;implementation des genes composes&#34;&#34;&#34;
    taux_mutation_new_componant = 0.3

    def __init__(self, len_x, len_y, composants = 10):
        self.len_x = len_x
        self.len_y = len_y
        if isinstance(composants, int):
            self.composants = [Composant.random(len_x, len_y) for _ in range(composants)]
        else:
            self.composants = composants
        self.fit = None

    def __repr__(self):
        chaine = &#34;&#34;
        for elem in self.composants:
            chaine += &#34;{}\n&#34;.format(elem.__repr__())
        return &#34;gene compose ({0},{1}) :\n{2}&#34;.format(self.len_x, self.len_y, chaine)

    def mutation(self):
        for elem in self.composants:
            elem.mutation()

        if rd.random() &lt;= Gene_compose.taux_mutation_new_componant:
            self.composants.append(Composant.random(self.len_x, self.len_y))

    def __mul__(self, other):
        parent_A = [None for _ in range(Composant.next_id)]
        parent_B = [None for _ in range(Composant.next_id)]
        for composant in self.composants:
            parent_A[composant.id] = composant
        for composant in other.composants:
            parent_B[composant.id] = composant
        fils = [None for _ in range(Composant.next_id)]
        for i in range(Composant.next_id):
            comp_a = parent_A[i]
            comp_b = parent_B[i]
            if (comp_a == None) and (comp_b == None):
                pass
            elif isinstance(comp_a, Composant) and isinstance(comp_b, Composant):
                fils[i] = (comp_a | comp_b).copy()
            elif isinstance(comp_a, Composant) and (comp_b == None):
                fils[i] = comp_a.copy()
            elif isinstance(comp_b, Composant) and (comp_a == None):
                fils[i] = comp_b.copy()
            else:
                raise ValueError
        gene = Gene_compose(self.len_x, self.len_y, [elem for elem in fils if elem != None])
        return gene

    def jardin(self):
        jar = simulateur.Jardin(self.len_x, self.len_y)
        for comp in self.composants:
            if comp.actif:
                try:
                    empl = jar.emplacement[comp.position[1]][comp.position[0]]
                    plante = comp.espece()
                    plante.planter(empl, comp.plantage, comp.recolte,jar)

                except ValueError:
                    pass
        return jar
    
    def recette(self):
        &#34;&#34;&#34;permet de convertir le gene en un texte comprehensible pour l&#39;utilisateur representant la plannification des cultures du jardin&#34;&#34;&#34;
        jar = simulateur.Jardin(self.len_x, self.len_y)
        liste_commande = []
        for comp in self.composants:
            if comp.actif:
                try:
                    empl = jar.emplacement[comp.position[1]][comp.position[0]]
                    plante = comp.espece()
                    plante.planter(empl, comp.plantage, comp.recolte, jar)
                    liste_commande.append(&#34;le jour {:0&gt;3}, en ({},{}), planter des {}&#34;.format(comp.plantage, comp.position[1], comp.position[0], plante))
                    liste_commande.append(&#34;le jour {:0&gt;3}, en ({},{}), recolter des {}&#34;.format(comp.recolte, comp.position[1], comp.position[0], plante))
                except ValueError:
                    pass
        liste_commande.sort()
        return &#34;\n&#34;.join(liste_commande)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="genetique.Gene" href="#genetique.Gene">Gene</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="genetique.Gene_compose.taux_mutation_new_componant"><code class="name">var <span class="ident">taux_mutation_new_componant</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genetique.Gene_compose.recette"><code class="name flex">
<span>def <span class="ident">recette</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>permet de convertir le gene en un texte comprehensible pour l'utilisateur representant la plannification des cultures du jardin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recette(self):
    &#34;&#34;&#34;permet de convertir le gene en un texte comprehensible pour l&#39;utilisateur representant la plannification des cultures du jardin&#34;&#34;&#34;
    jar = simulateur.Jardin(self.len_x, self.len_y)
    liste_commande = []
    for comp in self.composants:
        if comp.actif:
            try:
                empl = jar.emplacement[comp.position[1]][comp.position[0]]
                plante = comp.espece()
                plante.planter(empl, comp.plantage, comp.recolte, jar)
                liste_commande.append(&#34;le jour {:0&gt;3}, en ({},{}), planter des {}&#34;.format(comp.plantage, comp.position[1], comp.position[0], plante))
                liste_commande.append(&#34;le jour {:0&gt;3}, en ({},{}), recolter des {}&#34;.format(comp.recolte, comp.position[1], comp.position[0], plante))
            except ValueError:
                pass
    liste_commande.sort()
    return &#34;\n&#34;.join(liste_commande)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="genetique.Gene" href="#genetique.Gene">Gene</a></b></code>:
<ul class="hlist">
<li><code><a title="genetique.Gene.fitness" href="#genetique.Gene.fitness">fitness</a></code></li>
<li><code><a title="genetique.Gene.jardin" href="#genetique.Gene.jardin">jardin</a></code></li>
<li><code><a title="genetique.Gene.mutation" href="#genetique.Gene.mutation">mutation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="genetique.Gene_naif"><code class="flex name class">
<span>class <span class="ident">Gene_naif</span></span>
<span>(</span><span>len_x, len_y, ADN='')</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation de la representation naive, le gène est une chaine de caractère</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gene_naif(Gene):
    &#34;&#34;&#34;Implementation de la representation naive, le gène est une chaine de caractère&#34;&#34;&#34;
    taux_mutation_carra = 0.05
    pourcentage_max_mutation = 0.3

    def __init__(self, len_x, len_y, ADN=&#34;&#34;):
        def generateur_aleatoire_mais_pas_trop():
            decodeur_espece = Gene.decodeur_espece
            calendrier = [0]*365
            ADN = [0]*365
            iterateur = 0
            while iterateur &lt; 365:
                identificateur = &#34;&#34;
                for i in range(N_bit_espece):
                    identificateur += str(rd.randint(0,1))
                plante_aléatoire = decodeur_espece[identificateur]
                if identificateur == N_bit_espece*&#34;0&#34;:

                    ADN[iterateur] =  N_bit_espece*&#34;0&#34;
                    iterateur += 1
                else:
                    time_chunk = plante_aléatoire().time_chunk
                    if iterateur + time_chunk &lt; 363:
                        calendrier[iterateur:iterateur + time_chunk] = [plante_aléatoire()]*time_chunk
                        ADN[iterateur:iterateur + time_chunk] = [identificateur]*time_chunk
                        calendrier[iterateur + time_chunk] = simulateur.Jachere()
                        ADN[iterateur + time_chunk] = N_bit_espece*&#34;0&#34;
                        iterateur += time_chunk + 1
                    else:
                        calendrier[iterateur:365] = [plante_aléatoire()]*(364-iterateur +1)
                        ADN[iterateur:365] = [identificateur]*(364-iterateur +1)
                        iterateur = 365
            return &#34;&#34;.join(ADN)
        self.len_x = len_x
        self.len_y = len_y
        if ADN:
            self.ADN = ADN
        else:
            self.ADN = &#34;&#34;
            for x in range(len_x):
                for y in range(len_y):
                    self.ADN += generateur_aleatoire_mais_pas_trop()
                    #print(self.ADN)
        self.fit = None

    @classmethod
    def from_file(cls, adn, fit, len_x, len_y):
        &#34;&#34;&#34;
        reconstruit le gene à partir des informations contenues dans le fichier de sauvegarde

        Parameters
        ----------
        cls : type
            DESCRIPTION.
        adn : str
            chaine binaire du gene
        fit : float or None
            fitness du gene
        len_x : int
            DESCRIPTION.
        len_y : int
            DESCRIPTION.

        Returns
        -------
        gene : Gene
            gene reconstruit

        &#34;&#34;&#34;
        gene = cls(len_x, len_y, adn)
        gene.fit = fit
        return gene

    def __str__(self):
        return &#34;{};{}&#34;.format(self.fit, hex(int(self.ADN, 2)))

    def __repr__(self):
        n = int(self.ADN, 2)
        return &#34;gene : {}&#34;.format(hex(n))

    def jardin(self) -&gt; simulateur.Jardin:
        jar = simulateur.Jardin(self.len_x, self.len_y)
        for x in range(self.len_x):
            for y in range(self.len_y):
                emplacement = jar.emplacement[y][x]
                ebauche = []
                for jour in range(365):
                    allele = self.ADN[(x + (y * self.len_x)) * 365 + N_bit_espece*jour :
                                      (x + (y * self.len_x)) * 365 + N_bit_espece*jour
                                      + N_bit_espece]
                    try:
                        ebauche += [Gene.decodeur_espece[allele]]
                    except KeyError:
                        ebauche += [simulateur.Jachere]
                idx_exploration = 0
                while idx_exploration &lt; 365:
                    type_actuel = ebauche[idx_exploration]
                    if type_actuel == simulateur.Jachere:
                        idx_exploration += 1
                    else:
                        idx_depart = idx_exploration
                        while (idx_exploration &lt; 365) and ebauche[idx_exploration] == type_actuel:
                            idx_exploration += 1
                        idx_fin = idx_exploration
                        plante = type_actuel()
                        try:
                            plante.planter(emplacement, idx_depart, idx_fin, jar) #,x,y,jar)
                        except ValueError:
                            pass
        return jar

    def __mul__(self, other):
        idx_coupe = rd.randint(0, len(self.ADN))
        return Gene_naif(self.len_x, self.len_y, self.ADN[:idx_coupe] + other.ADN[idx_coupe:])

    def mutation(self):
        if rd.random() &lt; Gene_naif.taux_mutation_carra:
            nbr_caractere_a_muter = rd.randint(1, round(Gene_naif.pourcentage_max_mutation*len(self.ADN)))
            place_caractere = rd.randint(0, len(self.ADN)-nbr_caractere_a_muter-1)
            inverse = &#34;&#34;
            for bit in self.ADN[place_caractere:place_caractere+nbr_caractere_a_muter]:
                if bit == &#34;0&#34;:
                    inverse += &#34;1&#34;
                else:
                    inverse += &#34;0&#34;
            if ((len(self.ADN[:place_caractere]
                    + inverse
                    + self.ADN[place_caractere
                               + nbr_caractere_a_muter:])) !=
                                                            len(self.ADN)):
                raise ValueError
            else:
                self.ADN = self.ADN[place_caractere] + inverse + self.ADN[place_caractere + nbr_caractere_a_muter:]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="genetique.Gene" href="#genetique.Gene">Gene</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="genetique.Gene_naif.pourcentage_max_mutation"><code class="name">var <span class="ident">pourcentage_max_mutation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="genetique.Gene_naif.taux_mutation_carra"><code class="name">var <span class="ident">taux_mutation_carra</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="genetique.Gene_naif.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>adn, fit, len_x, len_y)</span>
</code></dt>
<dd>
<div class="desc"><p>reconstruit le gene à partir des informations contenues dans le fichier de sauvegarde</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>type</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>adn</code></strong> :&ensp;<code>str</code></dt>
<dd>chaine binaire du gene</dd>
<dt><strong><code>fit</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>fitness du gene</dd>
<dt><strong><code>len_x</code></strong> :&ensp;<code>int</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>len_y</code></strong> :&ensp;<code>int</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gene</code></strong> :&ensp;<code><a title="genetique.Gene" href="#genetique.Gene">Gene</a></code></dt>
<dd>gene reconstruit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, adn, fit, len_x, len_y):
    &#34;&#34;&#34;
    reconstruit le gene à partir des informations contenues dans le fichier de sauvegarde

    Parameters
    ----------
    cls : type
        DESCRIPTION.
    adn : str
        chaine binaire du gene
    fit : float or None
        fitness du gene
    len_x : int
        DESCRIPTION.
    len_y : int
        DESCRIPTION.

    Returns
    -------
    gene : Gene
        gene reconstruit

    &#34;&#34;&#34;
    gene = cls(len_x, len_y, adn)
    gene.fit = fit
    return gene</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="genetique.Gene" href="#genetique.Gene">Gene</a></b></code>:
<ul class="hlist">
<li><code><a title="genetique.Gene.fitness" href="#genetique.Gene.fitness">fitness</a></code></li>
<li><code><a title="genetique.Gene.jardin" href="#genetique.Gene.jardin">jardin</a></code></li>
<li><code><a title="genetique.Gene.mutation" href="#genetique.Gene.mutation">mutation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="genetique.Generation"><code class="flex name class">
<span>class <span class="ident">Generation</span></span>
<span>(</span><span>genes)</span>
</code></dt>
<dd>
<div class="desc"><p>objet permettant de representer une generation dans l'algorithme</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Generation():
    &#34;&#34;&#34;objet permettant de representer une generation dans l&#39;algorithme&#34;&#34;&#34;
    multithreading_actif = False
    
    @classmethod
    def from_file(cls, path):
        &#34;&#34;&#34;
        reconstruit la generation a partir d&#39;un fichier

        Parameters
        ----------
        cls : type
            DESCRIPTION.
        path : str
            chemin du fichier contenant la sauvegarde

        Raises
        ------
        IOError
            DESCRIPTION.
        Exception
            DESCRIPTION.

        Returns
        -------
        generation : Generation
            generation corespondant au fichier

        &#34;&#34;&#34;
        try:
            file = open(path+&#34;.txt&#34;, &#34;r&#34;)
            lines = file.readlines()
            file.close()
        except Exception:
            raise IOError(&#34;&#34;&#34;le fichier &#34;{}&#34; ne s&#39;ouvre pas&#34;&#34;&#34;.format(path+&#34;.txt&#34;))
        try:
            en_tete = lines.pop(0)
            en_tete = en_tete.split(&#34;;&#34;)
            len_x = int(en_tete[0])
            len_y = int(en_tete[1])
            evaluee = bool(int(en_tete[2]))
        except Exception:
            raise Exception(&#34;&#34;&#34;Entete invalide&#34;&#34;&#34;)
        try:
            genes = []
            for n, ligne in enumerate(lines):
                ligne = ligne.split(&#39;;&#39;)
                fit = ligne[0]
                adn = ligne[1][:-1]
                adn = bin(int(adn, 16))[2:]
                if evaluee:
                    fit = float(fit)
                else:
                    fit = None
                genes.append(Gene_naif.from_file(adn, fit, len_x, len_y))
        except Exception:
            Exception(&#34;&#34;&#34;Contenu invalide ligne {}&#34;&#34;&#34;.format(n))

        generation = cls(genes)
        generation.evaluee = evaluee
        return generation

    def __init__(self, genes):
        self.genes = []
        for elem in genes:
            if not isinstance(elem, Gene):
                raise TypeError(&#34;Ce n&#39;est pas un gene&#34;)
            self.genes.append(elem)
        self.evaluee = False

    def generation_suivante(self):
        &#34;&#34;&#34;
        calcule la génération suivante

        Returns
        -------
        Generation
            La generation suivante

        &#34;&#34;&#34;
        N = len(self.genes)
        self.evaluation()
        gene = self._selection()

        new_gene = []
        while len(new_gene) &lt;= N:
            g1 = rd.choice(gene)
            g2 = rd.choice(gene)
            g = (g1 * g2)
            g.mutation()
            new_gene.append(g)
        gen_suivante = Generation(new_gene)
        return gen_suivante

    def evaluation(self):
        &#34;&#34;&#34;
        Permet de trier la liste des genes dans l&#39;odre décroissant de qualité

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if Generation.multithreading_actif :
            liste_evaluateur = []
            for gene in self.genes:
                liste_evaluateur.append(Evaluateur(gene))
            
            for evaluateur in liste_evaluateur:
                evaluateur.start()
            
            for evaluateur in liste_evaluateur:
                evaluateur.join()
            
        self.genes.sort(key=Gene.fitness, reverse=True)
        self.evaluee = True

    def _selection(self) -&gt; list:
        &#34;&#34;&#34;
        Permet de selectionner les 10% meilleurs élements de la liste de genes, Cette dernière doit être triée du meilleur [0] au moins bon [-1].

        Returns
        -------
        None.

        &#34;&#34;&#34;

        if self.evaluee == False:
            self.evaluation()
        selection = []
        selection += self.genes[:(len(self.genes)//10)]
        weight = [gene.fitness() for gene in self.genes[(len(self.genes)//10):]]
        selection += rd.choices(self.genes[(len(self.genes)//10):], weight, k = len(selection))
        return selection

    def __str__(self):
        chaine = &#34;{1};{2};{0}\n&#34;.format(int(self.evaluee), self.genes[0].len_x,  self.genes[0].len_y)
        for gene in self.genes:
            chaine += str(gene)+&#34;\n&#34;
        return chaine

    def save(self, nom, emplacement = &#34;save&#34;):
        &#34;&#34;&#34;
        enregistre la géneration dans un fichier

        Parameters
        ----------
        nom : str
            nom de la sauvegarde
        emplacement : str, optional
            emplacement de la sauvegarde. The default is &#34;save&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        file = open(emplacement + &#34;/&#34; + nom + &#39;.txt&#39;, &#39;w&#39;)
        file.write(str(self))
        file.close()

    def get_fitness(self):
        &#34;&#34;&#34;
        renvoit la liste des fitness de la generation

        Returns
        -------
        fitness : list[int]
            liste des fitness de la generation

        &#34;&#34;&#34;
        if not self.evaluee:
            self.evaluation()
        fitness = []
        for gene in self.genes:
            fitness.append(gene.fit)
        return fitness</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="genetique.Generation.multithreading_actif"><code class="name">var <span class="ident">multithreading_actif</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="genetique.Generation.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>reconstruit la generation a partir d'un fichier</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>type</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>chemin du fichier contenant la sauvegarde</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IOError</code></dt>
<dd>DESCRIPTION.</dd>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>generation</code></strong> :&ensp;<code><a title="genetique.Generation" href="#genetique.Generation">Generation</a></code></dt>
<dd>generation corespondant au fichier</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, path):
    &#34;&#34;&#34;
    reconstruit la generation a partir d&#39;un fichier

    Parameters
    ----------
    cls : type
        DESCRIPTION.
    path : str
        chemin du fichier contenant la sauvegarde

    Raises
    ------
    IOError
        DESCRIPTION.
    Exception
        DESCRIPTION.

    Returns
    -------
    generation : Generation
        generation corespondant au fichier

    &#34;&#34;&#34;
    try:
        file = open(path+&#34;.txt&#34;, &#34;r&#34;)
        lines = file.readlines()
        file.close()
    except Exception:
        raise IOError(&#34;&#34;&#34;le fichier &#34;{}&#34; ne s&#39;ouvre pas&#34;&#34;&#34;.format(path+&#34;.txt&#34;))
    try:
        en_tete = lines.pop(0)
        en_tete = en_tete.split(&#34;;&#34;)
        len_x = int(en_tete[0])
        len_y = int(en_tete[1])
        evaluee = bool(int(en_tete[2]))
    except Exception:
        raise Exception(&#34;&#34;&#34;Entete invalide&#34;&#34;&#34;)
    try:
        genes = []
        for n, ligne in enumerate(lines):
            ligne = ligne.split(&#39;;&#39;)
            fit = ligne[0]
            adn = ligne[1][:-1]
            adn = bin(int(adn, 16))[2:]
            if evaluee:
                fit = float(fit)
            else:
                fit = None
            genes.append(Gene_naif.from_file(adn, fit, len_x, len_y))
    except Exception:
        Exception(&#34;&#34;&#34;Contenu invalide ligne {}&#34;&#34;&#34;.format(n))

    generation = cls(genes)
    generation.evaluee = evaluee
    return generation</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="genetique.Generation.evaluation"><code class="name flex">
<span>def <span class="ident">evaluation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Permet de trier la liste des genes dans l'odre décroissant de qualité</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluation(self):
    &#34;&#34;&#34;
    Permet de trier la liste des genes dans l&#39;odre décroissant de qualité

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if Generation.multithreading_actif :
        liste_evaluateur = []
        for gene in self.genes:
            liste_evaluateur.append(Evaluateur(gene))
        
        for evaluateur in liste_evaluateur:
            evaluateur.start()
        
        for evaluateur in liste_evaluateur:
            evaluateur.join()
        
    self.genes.sort(key=Gene.fitness, reverse=True)
    self.evaluee = True</code></pre>
</details>
</dd>
<dt id="genetique.Generation.generation_suivante"><code class="name flex">
<span>def <span class="ident">generation_suivante</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>calcule la génération suivante</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="genetique.Generation" href="#genetique.Generation">Generation</a></code></dt>
<dd>La generation suivante</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generation_suivante(self):
    &#34;&#34;&#34;
    calcule la génération suivante

    Returns
    -------
    Generation
        La generation suivante

    &#34;&#34;&#34;
    N = len(self.genes)
    self.evaluation()
    gene = self._selection()

    new_gene = []
    while len(new_gene) &lt;= N:
        g1 = rd.choice(gene)
        g2 = rd.choice(gene)
        g = (g1 * g2)
        g.mutation()
        new_gene.append(g)
    gen_suivante = Generation(new_gene)
    return gen_suivante</code></pre>
</details>
</dd>
<dt id="genetique.Generation.get_fitness"><code class="name flex">
<span>def <span class="ident">get_fitness</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>renvoit la liste des fitness de la generation</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fitness</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>liste des fitness de la generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fitness(self):
    &#34;&#34;&#34;
    renvoit la liste des fitness de la generation

    Returns
    -------
    fitness : list[int]
        liste des fitness de la generation

    &#34;&#34;&#34;
    if not self.evaluee:
        self.evaluation()
    fitness = []
    for gene in self.genes:
        fitness.append(gene.fit)
    return fitness</code></pre>
</details>
</dd>
<dt id="genetique.Generation.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, nom, emplacement='save')</span>
</code></dt>
<dd>
<div class="desc"><p>enregistre la géneration dans un fichier</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nom</code></strong> :&ensp;<code>str</code></dt>
<dd>nom de la sauvegarde</dd>
<dt><strong><code>emplacement</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>emplacement de la sauvegarde. The default is "save".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, nom, emplacement = &#34;save&#34;):
    &#34;&#34;&#34;
    enregistre la géneration dans un fichier

    Parameters
    ----------
    nom : str
        nom de la sauvegarde
    emplacement : str, optional
        emplacement de la sauvegarde. The default is &#34;save&#34;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    file = open(emplacement + &#34;/&#34; + nom + &#39;.txt&#39;, &#39;w&#39;)
    file.write(str(self))
    file.close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="genetique.Composant" href="#genetique.Composant">Composant</a></code></h4>
<ul class="">
<li><code><a title="genetique.Composant.copy" href="#genetique.Composant.copy">copy</a></code></li>
<li><code><a title="genetique.Composant.ecart_type_mutation_date" href="#genetique.Composant.ecart_type_mutation_date">ecart_type_mutation_date</a></code></li>
<li><code><a title="genetique.Composant.mutation" href="#genetique.Composant.mutation">mutation</a></code></li>
<li><code><a title="genetique.Composant.next_id" href="#genetique.Composant.next_id">next_id</a></code></li>
<li><code><a title="genetique.Composant.random" href="#genetique.Composant.random">random</a></code></li>
<li><code><a title="genetique.Composant.taux_mutation_activite" href="#genetique.Composant.taux_mutation_activite">taux_mutation_activite</a></code></li>
<li><code><a title="genetique.Composant.taux_mutation_date" href="#genetique.Composant.taux_mutation_date">taux_mutation_date</a></code></li>
<li><code><a title="genetique.Composant.taux_mutation_position" href="#genetique.Composant.taux_mutation_position">taux_mutation_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genetique.Essai" href="#genetique.Essai">Essai</a></code></h4>
<ul class="">
<li><code><a title="genetique.Essai.composee_vide" href="#genetique.Essai.composee_vide">composee_vide</a></code></li>
<li><code><a title="genetique.Essai.evolution_statistique" href="#genetique.Essai.evolution_statistique">evolution_statistique</a></code></li>
<li><code><a title="genetique.Essai.generation_suivante" href="#genetique.Essai.generation_suivante">generation_suivante</a></code></li>
<li><code><a title="genetique.Essai.load_save" href="#genetique.Essai.load_save">load_save</a></code></li>
<li><code><a title="genetique.Essai.naif_non_random" href="#genetique.Essai.naif_non_random">naif_non_random</a></code></li>
<li><code><a title="genetique.Essai.save" href="#genetique.Essai.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genetique.Evaluateur" href="#genetique.Evaluateur">Evaluateur</a></code></h4>
<ul class="">
<li><code><a title="genetique.Evaluateur.run" href="#genetique.Evaluateur.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genetique.Gene" href="#genetique.Gene">Gene</a></code></h4>
<ul class="">
<li><code><a title="genetique.Gene.decodeur_espece" href="#genetique.Gene.decodeur_espece">decodeur_espece</a></code></li>
<li><code><a title="genetique.Gene.fitness" href="#genetique.Gene.fitness">fitness</a></code></li>
<li><code><a title="genetique.Gene.jardin" href="#genetique.Gene.jardin">jardin</a></code></li>
<li><code><a title="genetique.Gene.mutation" href="#genetique.Gene.mutation">mutation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genetique.Gene_compose" href="#genetique.Gene_compose">Gene_compose</a></code></h4>
<ul class="">
<li><code><a title="genetique.Gene_compose.recette" href="#genetique.Gene_compose.recette">recette</a></code></li>
<li><code><a title="genetique.Gene_compose.taux_mutation_new_componant" href="#genetique.Gene_compose.taux_mutation_new_componant">taux_mutation_new_componant</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genetique.Gene_naif" href="#genetique.Gene_naif">Gene_naif</a></code></h4>
<ul class="">
<li><code><a title="genetique.Gene_naif.from_file" href="#genetique.Gene_naif.from_file">from_file</a></code></li>
<li><code><a title="genetique.Gene_naif.pourcentage_max_mutation" href="#genetique.Gene_naif.pourcentage_max_mutation">pourcentage_max_mutation</a></code></li>
<li><code><a title="genetique.Gene_naif.taux_mutation_carra" href="#genetique.Gene_naif.taux_mutation_carra">taux_mutation_carra</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="genetique.Generation" href="#genetique.Generation">Generation</a></code></h4>
<ul class="">
<li><code><a title="genetique.Generation.evaluation" href="#genetique.Generation.evaluation">evaluation</a></code></li>
<li><code><a title="genetique.Generation.from_file" href="#genetique.Generation.from_file">from_file</a></code></li>
<li><code><a title="genetique.Generation.generation_suivante" href="#genetique.Generation.generation_suivante">generation_suivante</a></code></li>
<li><code><a title="genetique.Generation.get_fitness" href="#genetique.Generation.get_fitness">get_fitness</a></code></li>
<li><code><a title="genetique.Generation.multithreading_actif" href="#genetique.Generation.multithreading_actif">multithreading_actif</a></code></li>
<li><code><a title="genetique.Generation.save" href="#genetique.Generation.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>